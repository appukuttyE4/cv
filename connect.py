# -*- coding: utf-8 -*-
"""CV_Connectivity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YgT-z7_374cPnl3BFCz6m2SFJjUNIfrj
"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
import random

#reading the image 
image = cv2.imread('cv_image.jpg')
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
(thresh, bw_image) = cv2.threshold(gray_image, 127, 255, cv2.THRESH_BINARY)
#Display 
cv2_imshow(bw_image)

img_height = bw_image.shape[0]
img_width = bw_image.shape[1]

background = 0
current_pixel = 0
pixel_above = 0
pixel_left = 0
equivalency_table = {}

# Iterate through pixels and assign labels

for a in range(img_height): # a - rows
  for b in range(img_width): # b - columns
    if bw_image[a][b] != background:
      
      # Checking the position of current pixel
      if a > 0:
        # look at pixel above
        pixel_above = bw_image[a-1][b]
      
      if b > 0:
        # look at pixel left
        pixel_left = bw_image[a][b-1]
      
      if pixel_above != background and pixel_left != background:
        label = min(pixel_above, pixel_left)
        equivalency_table[max(pixel_above, pixel_left)] = label
      elif pixel_above != background:
        label = pixel_above
      elif pixel_left != background:
        label = pixel_left
      else:
        # Assign new label if both are background pixels
        current_pixel += 1
        equivalency_table[current_pixel] = current_pixel
        label = current_pixel

      bw_image[a][b] = label


print("\nEquivalency Table: " + str(equivalency_table))

for k in range(len(equivalency_table)):
	for i in range(a):
	    for j in range(b):
	        if bw_image[i][j] in equivalency_table:
	            bw_image[i][j] = equivalency_table[bw_image[i][j]]


print("Image:\n\n " + str(bw_image))

# Image coloring

output_img = np.zeros((a, b, 3), int)
labelColor = {0: (0, 0, 0)}
for i in range(a):
    for j in range(b):
        label = bw_image[i,j]
        if label not in labelColor:
            labelColor[label] = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
        output_img[i, j, :] = labelColor[label]
        
print('\n')
cv2_imshow(output_img)

#6 connectivity

#1 - White
#0 - Black


img_height = bw_image.shape[0]
img_width = bw_image.shape[1]

background = 0
current_pixel = 0
pixel_above = 0
pixel_left = 0
pixel_diag=0
equivalency_table = {}
max_v=0
# Iterate through pixels and assign labels

for a in range(img_height): # a - rows
  for b in range(img_width): # b - columns
    if bw_image[a][b] != background:
      
      # Checking the position of current pixel
      if a > 0:
        # look at pixel above
        pixel_above = bw_image[a-1][b]
      
      if b > 0:
        # look at pixel left
        pixel_left = bw_image[a][b-1]
      
      if (a>0 and b>0):
          pixel_diag=bw_image[a-1][b-1]

      if pixel_above != background and pixel_left != background and pixel_diag!=background:
        label = pixel_above  #if collision occurs we are taking the min of two 
        equivalency_table[max(pixel_above, pixel_left,pixel_diag)] = label #assinging the max label with min label 
      elif pixel_above != background:
        label = pixel_above
      elif pixel_left != background:
        label = pixel_left
      elif pixel_diag != background:
        label = pixel_diag
      else:
        # Assign new label if left and above are background pixels
        current_pixel += 1
        equivalency_table[current_pixel] = current_pixel
        label = current_pixel

      bw_image[a][b] = label
      max_v=max(label,max_v)


# Update labels based on equivalency list

print("a: ",a," b:", b)
print(max_v)
for k in range(len(equivalency_table)):
	for i in range(a):
	    for j in range(b):
	        if bw_image[i][j] in equivalency_table:
	            bw_image[i][j] = equivalency_table[bw_image[i][j]]

print("Image:\n\n " + str(bw_image))
print("\nEquivalency Table: " + str(equivalency_table))

# Image coloring

output_img = np.zeros((a, b, 3), int)
labelColor = {0: (0, 0, 0)}
for i in range(a):
    for j in range(b):
        label = bw_image[i,j]
        if label not in labelColor:
            labelColor[label] = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
        output_img[i, j, :] = labelColor[label]
        

#Cv2.imwrite('output_img.png', output_img)
print('\n')
cv2_imshow(output_img)

# Converting the B/W image to an array

bw_image = bw_image.astype(float) / 255
image_array = np.asarray(bw_image)
print(image_array)

from google.colab.patches import cv2_imshow

import cv2
import numpy as np

img = cv2.imread('cv_image.jpg', 0)
img = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)[1]  # ensure binary
num_labels, labels_im = cv2.connectedComponents(img)

def imshow_components(labels):
    # Map component labels to hue val
    label_hue = np.uint8(179*labels/np.max(labels))
    blank_ch = 255*np.ones_like(label_hue)
    labeled_img = cv2.merge([label_hue, blank_ch, blank_ch])

    # cvt to BGR for display
    labeled_img = cv2.cvtColor(labeled_img, cv2.COLOR_HSV2BGR)

    # set bg label to black
    labeled_img[label_hue==0] = 0

    cv2_imshow(labeled_img)
    #cv2_waitKey()

imshow_components(labels_im)

